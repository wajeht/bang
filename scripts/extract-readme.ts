import fs from 'fs';
import path from 'path';
import { marked } from 'marked';
import { Logger } from '../src/utils/logger';

const logger = Logger({ service: 'extract-readme script' });

interface ExtractionResult {
    error?: string;
    success: boolean;
    outputPath?: string;
    usageLength?: number;
    htmlLength?: number;
}

async function extractReadmeUsage(): Promise<ExtractionResult> {
    try {
        const readmePath = path.join(__dirname, '..', 'README.md');
        const componentsDir = path.join(__dirname, '..', 'src', 'routes', '_components');
        const outputPath = path.join(componentsDir, 'readme-usage.html');

        if (!fs.existsSync(readmePath)) {
            return {
                success: false,
                error: 'README.md not found',
            };
        }

        if (fs.existsSync(outputPath)) {
            const readmeStat = fs.statSync(readmePath);
            const outputStat = fs.statSync(outputPath);

            if (readmeStat.mtimeMs <= outputStat.mtimeMs) {
                logger.info('README unchanged, skipping extraction');
                process.exit(0);
            }
        }

        const readmeContent = fs.readFileSync(readmePath, 'utf8');

        const start = '<!-- starts -->';
        const end = '<!-- ends -->';

        const startIndex = readmeContent.indexOf(start);
        const endIndex = readmeContent.indexOf(end);

        if (startIndex === -1 || endIndex === -1 || endIndex <= startIndex) {
            return {
                success: false,
                error: 'Could not find usage section markers in README.md. Expected <!-- starts --> and <!-- ends --> markers.',
            };
        }

        const usageContent = readmeContent.slice(startIndex + start.length, endIndex).trim();

        if (!usageContent) {
            return {
                success: false,
                error: 'Usage content is empty between markers',
            };
        }

        let html =
            '<!-- THIS FILE IS GENERATED BY `npm run extract:readme` SCRIPT. DO NOT MODIFIY THIS MANUALLY! --> \n' +
            (await marked(usageContent));

        if (!fs.existsSync(componentsDir)) {
            fs.mkdirSync(componentsDir, { recursive: true });
        }

        fs.writeFileSync(outputPath, html, 'utf8');

        return {
            success: true,
            outputPath,
            usageLength: usageContent.length,
            htmlLength: html.length,
        };
    } catch (error) {
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred',
        };
    }
}

function printExtractionTable(result: ExtractionResult): void {
    logger.info('\nüìñ README EXTRACTION SUMMARY');

    if (result.success && result.outputPath) {
        const tableData = [
            {
                Status: '‚úÖ SUCCESS',
                'Output File': path.relative(process.cwd(), result.outputPath),
                'Markdown Size': `${result.usageLength} characters`,
                'HTML Size': `${result.htmlLength} characters`,
                'Size Change': `${((result.htmlLength! / result.usageLength! - 1) * 100).toFixed(1)}%`,
            },
        ];

        logger.table(tableData);
    } else {
        const tableData = [
            {
                Status: '‚ùå FAILED',
                Error: result.error || 'Unknown error',
            },
        ];

        logger.table(tableData);
    }
}

async function main(): Promise<void> {
    logger.info('üîç Extracting README usage section...');

    const result = await extractReadmeUsage();

    printExtractionTable(result);

    if (!result.success) {
        logger.error('‚ùå README extraction failed!');
        process.exit(1);
    } else {
        logger.info('‚úÖ README extraction completed successfully!');
    }
}

main().catch((error: any) => {
    logger.error('‚ùå Unexpected error: %o', error);
    process.exit(1);
});
